!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).WorkerInterface={})}(this,(function(e){"use strict";const t=Date.now()-Math.floor(1e3*Math.random());let r=0;var o;!function(e){e.THEN="then",e.CATCH="catch"}(o||(o={}));const s=e=>e===o.THEN||e===o.CATCH,n=(e="")=>{const o=`${e?`${e}/`:""}${t}/`;return()=>`${o}${++r};`},i=n();class a{constructor(e=i()){this.id=e}}class c{constructor(e,t,r,o){this.type=e,this.name=t,this.value=r,this.context=o}toObject(e=!1){const{type:t,name:r,value:o,context:s}=this;return{type:t,name:r,value:o,context:e?s:void 0}}toJSON(e=!1){const{type:t,name:r,value:o,context:s}=this;return JSON.stringify([t,r,o,e?s:void 0])}static fromJSON(e){const[t,r,o,s]=JSON.parse(e);return new c(t,r,o,s)}}class u extends c{constructor(e,t,r,o,s){super(t,r,o,s),this.prev=e}*[Symbol.iterator](){let e=this;for(;e;)yield e,e=e.prev}isTail(){return!this.prev}forEach(e){let t=this;do{e(t),t=t.prev}while(t)}map(e){let t=this;const r=[];do{r.push(e(t)),t=t.prev}while(t);return r}reduce(e,t){let r=this,o=t;do{o=e(o,r),r=r.prev}while(r);return o}static fromCommand({type:e,name:t,value:r,context:o},s){return new u(s,e,t,r,o)}}var p;!function(e){e.GET="P:get",e.SET="P:set",e.APPLY="P:apply",e.DELETE_PROPERTY="P:del",e.METHOD_CALL="P:call"}(p||(p={}));const d={arguments:!0,caller:!0,prototype:!0},l=Symbol("P:api"),h=(e,t,r={})=>{const o=Object.assign("function"==typeof e?function(...t){return e.apply(this,t)}:function(){},{target:e,[l]:{getTarget:()=>e,...r}});return new Proxy(o,t)},m=(f=Object.prototype.hasOwnProperty,(e,t)=>Boolean(e&&f.call(e,t)));var f;const y=e=>e===l||m(d,e),w=e=>(t,r)=>{const{target:o}=t;return y(r)?t[r]:e(p.GET,r,void 0,o)},v=e=>({target:t},r,o)=>e(p.APPLY,void 0,o,t),E=e=>({target:t},r,o)=>!y(r)&&(e(p.SET,r,o,t),!0),g=e=>(t,r)=>!y(r)&&(e(p.DELETE_PROPERTY,r,void 0,t.target),!0),b=(e,t)=>!!y(t)&&e[t],P=()=>Object.getOwnPropertyNames(d),T=()=>Object.getOwnPropertyNames(d)[Symbol.iterator](),x=(e,t)=>y(t)?Object.getOwnPropertyDescriptor(e,t):Object.getOwnPropertyDescriptor(e.target,t);class O{constructor(e){this.map=e,this.mapIterator=this.map.keys()}[Symbol.iterator](){return new O(this.map)}next(){let e,t,r;do{({done:r,value:e}=this.mapIterator.next()),r||(t=this.map.get(e).deref())}while(!r&&!t);return{done:r,value:e}}}class S{constructor(e){this.mapIterator=e}[Symbol.iterator](){return new S(this.mapIterator[Symbol.iterator]())}next(){let e,t,r;do{({done:r,value:e}=this.mapIterator.next()),t=r?void 0:e.deref()}while(!r&&!t);return{done:r,value:t}}}class L{constructor(e){this.mapIterator=e}[Symbol.iterator](){return new L(this.mapIterator[Symbol.iterator]())}next(){let e,t,r;do{({done:r,value:e}=this.mapIterator.next()),r?e=void 0:(t=e[1].deref(),e=[e[0],t])}while(!r&&!t);return{done:r,entries:e}}}class j{constructor(e=!0){this.map=new Map,e&&(this.finalizer=new FinalizationRegistry((e=>{const t=this.map.get(e);t&&t.deref()||this.map.delete(e)})))}get size(){return this.map.size}keys(){return new O(this.map)}values(){return new S(this.map.values())}entries(){return new L(this.map.entries())}set(e,t){this.map.set(e,new WeakRef(t))}get(e){const t=this.map.get(e);return t&&t.deref()}has(e){return!!this.get(e)}delete(e){return this.map.delete(e)}clear(){this.map.clear()}forEach(e){this.map.forEach(((t,r)=>{const o=t.deref();o&&e(o,r,this)}))}verify(){const e=new Map;this.map.forEach(((t,r)=>{t.deref()&&e.set(r,t)})),this.map.clear(),this.map=e}}class k extends a{constructor(e,t){super(),this.pool=e,this.type=t}toObject(){return{id:this.id,poolId:this.pool.id,type:this.type}}toJSON(){return JSON.stringify(this.toObject())}}const M=e=>e&&"object"==typeof e&&"string"==typeof e.id&&"string"==typeof e.poolId,C=new Set;var A;A=["object","function"],C.clear(),A.forEach((e=>C.add(e)));class I extends a{constructor(){super(...arguments),this.refs=new j,this.resources=new WeakMap}get active(){return!!this.resources}set(e,t){let r=null;return o=e,C.has(typeof o)?(r=this.resources.get(e),r||(r=((e,t,r)=>new k(e,r||typeof t))(this,e,t),this.refs.set(r.id,e),this.resources.set(e,r)),r):r;var o}has(e){return this.resources.has(e)}get({id:e}){return this.getById(e)}getById(e){return this.refs.get(e)}getResource(e){return this.resources.get(e)}remove(e){const t=this.resources.get(e);return!!t&&(this.refs.delete(t.id),this.resources.delete(e))}clear(){for(const e of this.refs.keys()){const t=this.refs.get(e);this.resources.delete(t)}this.refs.clear()}}const R=(e=>()=>(e||(e=new I),e))();class $ extends a{constructor(){super(),this.pools={},this.register(R())}createPool(){const e=new I;return this.register(e),e}register(e){return!m(this.pools,e.id)&&(this.pools[e.id]=e,!0)}get(e){return this.pools[e]||null}isRegistered(e){return m(this.pools,e.id)}remove(e){const t="string"==typeof e?e:e.id;return delete this.pools[t]}}const H=(e=>()=>(e||(e=new $),e))(),N=H().createPool(),D=e=>{if(!M(e))return e;const{poolId:t,id:r}=e,o=H().get(t);if(!o)throw new Error(`Resource Pool "${t}" does not exist.`);const s=o.getById(r);if(!s)throw new Error(`Resource "${r}" does not exist, pool "${t}".`);return s};var Y,G;!function(e){e.HOST="host",e.GUEST="guest"}(Y||(Y={})),function(e){e.REQUEST="request",e.RESPONSE="response"}(G||(G={}));const _=n("wi"),U=n("m"),W=async e=>{if(!e)return e;if(e instanceof Array){const t=[];for(let r of e)t.push(await W(r));return t}if((t=e)&&t[l]){const t=await(e=>e&&e[l]&&e[l].getTarget()||e)(e);return W(t)}var t;if("function"==typeof e){return N.set(e).toObject()}return e},z=(e="")=>t=>t&&"object"==typeof t&&"string"==typeof t.id&&(!e&&t.id.match(/^wi/)||e&&e===t.id),J=({handler:e,timeout:t,timeoutError:r=`Async operation didn't complete in ${t}ms.`,onTimeout:o})=>{const s="function"==typeof e?new Promise(e):e;return t?Promise.race([s,new Promise(((e,s)=>setTimeout((()=>{s(r),o&&o(r)}),t)))]):s},B=e=>e instanceof Event?e.data:e,q=({type:e,remoteId:t,handshakeTimeout:r,...o})=>{const s={...o,isMessage:z(t)},n=e===Y.HOST?(({id:e,root:t,isMessage:r,subscribe:o,unsubscribe:s,sendMessage:n})=>i=>{const a=o=>{const c=B(o);r(c)&&(s(a),n({id:e,root:t}),i(c))};o(a)})(s):(({id:e,root:t,isMessage:r,subscribe:o,unsubscribe:s,sendMessage:n,handshakeInterval:i})=>a=>{let c;const u=e=>{const t=B(e);r(t)&&(s(u),clearInterval(c),a(t))};o(u);const p=()=>n({id:e,root:t});i?c=setInterval(p,i):p()})(s);return J({handler:n,timeout:r,timeoutError:`Handshake sequence could not complete in ${r}ms.`})},Q="message",F=e=>{if(e)return e;if("object"==typeof self)return self;throw new Error('EventEmitter is not defined, please provide EventEmitter interface via "worker" or "eventEmitter" property.')},K=e=>{if(e)return e;if("object"==typeof self)return self;throw new Error('MessagePort is not defined, please provide MessagePort interface via "worker" or "messagePort" property.')},V=e=>{if(e.addEventListener)return{subscribe:t=>e.addEventListener(Q,t),unsubscribe:t=>e.removeEventListener(Q,t)};if(e.addListener)return{subscribe:t=>e.addListener(Q,t),unsubscribe:t=>e.removeListener(Q,t)};if(e.on)return{subscribe:t=>e.on(Q,t),unsubscribe:t=>e.off(Q,t)};throw new Error('Worker instance does not implement EventEmitter insterface, it must expose "addEventListener"/"removeEventListener", "addListener"/"removeListener" or "on"/"off" method pair.')},X=Promise.resolve(void 0),Z=(e,t,r)=>{switch(t){case o.THEN:return e.then(...r);case o.CATCH:return e.catch(...r);default:throw new Error(`Unexpected Error: Promise method "${String(t)}" could not be called.`)}},ee=(e,t=!0)=>(r,o)=>{const n=(r,o)=>{const i=(a=(r,i,a,c)=>{const d=((e,t,r,o,s,n)=>t===p.APPLY&&n&&e?.type===p.GET?new u(e.prev,p.METHOD_CALL,e.name,o,e.context):new u(e,t,r,o,s))(o,r,i,a,c,t);let l;return(e=>{const{type:t}=e;return t===p.GET||t===p.METHOD_CALL?s(e.name):t===p.APPLY&&s(e.prev?.name)})(d)?((e,t,r,o)=>{switch(e.type){case p.GET:{const{name:s,prev:n}=e;let{context:i}=e;if(r){if(!n)throw new Error("Unexpected Error: Proxy command GET has unknown context.");i=t(n,n.context,o)}return(...e)=>i[s](...e)}case p.METHOD_CALL:if(!e.context)throw new Error("Unexpected Error: Could not apply Promise method of unknown context.");return Z(e.context,e.name,e.value);case p.APPLY:{const{prev:t}=e;if(!t?.context||!t?.name)throw new Error("Unexpected Error: Could not apply Promise method of unknown context.");return Z(t.context,t.name,e.value)}default:throw new Error(`Command type "${e.type}" could not be executed as a Promise command.`)}})(d,e,t,n):(l=r!==p.APPLY&&r!==p.GET||!t?e(d,c,n):X,n(l,d))},{get:w(a),apply:v(a),set:E(a),deleteProperty:g(a),has:b,ownKeys:P,enumerate:T,getOwnPropertyDescriptor:x});var a;return h(r,i,{getCommand:()=>o,dropCommandChain(){o&&delete o.prev}})};return n(Promise.resolve(r),o?u.fromCommand(o):void 0)},te=async({id:e,root:t,...r})=>{const o=e||_(),s=t?N.set(t).toObject():void 0,{subscribe:n,unsubscribe:i,sendMessage:a}=r,{id:c,root:u}=await q({id:o,root:s,...r}),d=new Map,l=(h=o,e=>e&&"object"==typeof e&&"string"==typeof e.id&&h===e.target);var h;const m=((e,t)=>async(r,o,s=U())=>{const n=r.toObject(),i=await o;if(n.type===p.APPLY){let e;r.prev&&(e=await r.prev.context),n.value=[e,await W(n.value)]}else n.value=await W(n.value);return{id:s,type:G.REQUEST,source:e,target:t,command:n,context:i}})(o,c),f=(y=o,({id:e,source:t},r,o)=>({id:e,type:G.RESPONSE,source:y,target:t,value:r,error:o}));var y;const w=async e=>{const t=B(e);if(l(t))switch(t.type){case G.REQUEST:{const e=t;try{const t=await(({command:e,command:{type:t,value:r},context:o})=>{const s=D(o),n=e.name;if(t!==p.APPLY&&!s)throw new Error(`Cannot excute command ${t}/${String(n)} on non existent target(${s}).`);let i;switch(t){case p.GET:i=s[n];break;case p.SET:return s[n]=D(r);case p.DELETE_PROPERTY:return delete s[n];case p.APPLY:{const[e,t]=r;i=s.apply(D(e),t.map(D))}break;case p.METHOD_CALL:i=s[n](...r.map(D))}if(i&&"function"==typeof i)return N.set(i).toObject();return i})(e);a(f(e,t))}catch(t){a(f(e,void 0,{message:t.message}))}}break;case G.RESPONSE:{const{id:e,value:r,error:o}=t,{resolve:s,reject:n}=d.get(e)||{};n&&o?n(o):s&&s(r)}}};n(w);const v=()=>i(w);if(!u)return{stop:v,pool:N};const E=ee((async(e,t,o)=>{const{responseTimeout:s}=r,n=U(),i=`Could not receive command ${e.type}/${String(e.name)} response in ${s}ms.`,c=J({handler:async(r,o)=>{const s=await m(e,t,n);a(s),d.set(n,{resolve:r,reject:o})},timeout:s||0,timeoutError:i,onTimeout:()=>{const e=d.get(n);e&&(e.reject(new Error(i)),d.delete(n))}}),u=await c;return M(u)?o(c,e):c}),!1);return{stop:v,pool:N,wrap:E,pendingRequests:d,root:u?E(u):null}};e.initializeHost=async({worker:e,...t})=>{let r=e;if("string"==typeof e){if("undefined"==typeof Worker)throw new Error("Worker class is not available globally.");r=new Worker(e)}return te({...t,type:Y.HOST,sendMessage:e=>r.postMessage(e),...V(r)})},e.initializeWorker=async({worker:e,eventEmitter:t=F(e),messagePort:r=K(e),...o})=>te({...o,type:Y.GUEST,sendMessage:e=>r.postMessage(e),...V(t)}),Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=worker-interface.umd.js.map
