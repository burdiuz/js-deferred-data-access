!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).WebSocketInterface={})}(this,(function(e){"use strict";const t=Date.now()-Math.floor(1e3*Math.random());let r=0;var o;!function(e){e.THEN="then",e.CATCH="catch"}(o||(o={}));const s=e=>e===o.THEN||e===o.CATCH,n=(e="")=>{const o=`${e?`${e}/`:""}${t}/`;return()=>`${o}${++r};`},i=n();class a{constructor(e=i()){this.id=e}}class c{constructor(e,t,r,o){this.type=e,this.name=t,this.value=r,this.context=o}toObject(e=!1){const{type:t,name:r,value:o,context:s}=this;return{type:t,name:r,value:o,context:e?s:void 0}}toJSON(e=!1){const{type:t,name:r,value:o,context:s}=this;return JSON.stringify([t,r,o,e?s:void 0])}static fromJSON(e){const[t,r,o,s]=JSON.parse(e);return new c(t,r,o,s)}}class u extends c{constructor(e,t,r,o,s){super(t,r,o,s),this.prev=e}*[Symbol.iterator](){let e=this;for(;e;)yield e,e=e.prev}isTail(){return!this.prev}forEach(e){let t=this;do{e(t),t=t.prev}while(t)}map(e){let t=this;const r=[];do{r.push(e(t)),t=t.prev}while(t);return r}reduce(e,t){let r=this,o=t;do{o=e(o,r),r=r.prev}while(r);return o}static fromCommand({type:e,name:t,value:r,context:o},s){return new u(s,e,t,r,o)}}var d;!function(e){e.GET="P:get",e.SET="P:set",e.APPLY="P:apply",e.DELETE_PROPERTY="P:del",e.METHOD_CALL="P:call"}(d||(d={}));const p={arguments:!0,caller:!0,prototype:!0},l=Symbol("P:api"),h=(e,t,r={})=>{const o=Object.assign("function"==typeof e?function(...t){return e.apply(this,t)}:function(){},{target:e,[l]:{getTarget:()=>e,...r}});return new Proxy(o,t)},m=(f=Object.prototype.hasOwnProperty,(e,t)=>Boolean(e&&f.call(e,t)));var f;const v=e=>e===l||m(p,e),y=e=>(t,r)=>{const{target:o}=t;return v(r)?t[r]:e(d.GET,r,void 0,o)},w=e=>({target:t},r,o)=>e(d.APPLY,void 0,o,t),E=e=>({target:t},r,o)=>!v(r)&&(e(d.SET,r,o,t),!0),g=e=>(t,r)=>!v(r)&&(e(d.DELETE_PROPERTY,r,void 0,t.target),!0),b=(e,t)=>!!v(t)&&e[t],P=()=>Object.getOwnPropertyNames(p),T=()=>Object.getOwnPropertyNames(p)[Symbol.iterator](),S=(e,t)=>v(t)?Object.getOwnPropertyDescriptor(e,t):Object.getOwnPropertyDescriptor(e.target,t);class x{constructor(e){this.map=e,this.mapIterator=this.map.keys()}[Symbol.iterator](){return new x(this.map)}next(){let e,t,r;do{({done:r,value:e}=this.mapIterator.next()),r||(t=this.map.get(e).deref())}while(!r&&!t);return{done:r,value:e}}}class O{constructor(e){this.mapIterator=e}[Symbol.iterator](){return new O(this.mapIterator[Symbol.iterator]())}next(){let e,t,r;do{({done:r,value:e}=this.mapIterator.next()),t=r?void 0:e.deref()}while(!r&&!t);return{done:r,value:t}}}class L{constructor(e){this.mapIterator=e}[Symbol.iterator](){return new L(this.mapIterator[Symbol.iterator]())}next(){let e,t,r;do{({done:r,value:e}=this.mapIterator.next()),r?e=void 0:(t=e[1].deref(),e=[e[0],t])}while(!r&&!t);return{done:r,entries:e}}}class C{constructor(e=!0){this.map=new Map,e&&(this.finalizer=new FinalizationRegistry((e=>{const t=this.map.get(e);t&&t.deref()||this.map.delete(e)})))}get size(){return this.map.size}keys(){return new x(this.map)}values(){return new O(this.map.values())}entries(){return new L(this.map.entries())}set(e,t){this.map.set(e,new WeakRef(t))}get(e){const t=this.map.get(e);return t&&t.deref()}has(e){return!!this.get(e)}delete(e){return this.map.delete(e)}clear(){this.map.clear()}forEach(e){this.map.forEach(((t,r)=>{const o=t.deref();o&&e(o,r,this)}))}verify(){const e=new Map;this.map.forEach(((t,r)=>{t.deref()&&e.set(r,t)})),this.map.clear(),this.map=e}}class R extends a{constructor(e,t){super(),this.pool=e,this.type=t}toObject(){return{id:this.id,poolId:this.pool.id,type:this.type}}toJSON(){return JSON.stringify(this.toObject())}}const j=e=>e&&"object"==typeof e&&"string"==typeof e.id&&"string"==typeof e.poolId,k=new Set;var I;I=["object","function"],k.clear(),I.forEach((e=>k.add(e)));class A extends a{constructor(){super(...arguments),this.refs=new C,this.resources=new WeakMap}get active(){return!!this.resources}set(e,t){let r=null;return o=e,k.has(typeof o)?(r=this.resources.get(e),r||(r=((e,t,r)=>new R(e,r||typeof t))(this,e,t),this.refs.set(r.id,e),this.resources.set(e,r)),r):r;var o}has(e){return this.resources.has(e)}get({id:e}){return this.getById(e)}getById(e){return this.refs.get(e)}getResource(e){return this.resources.get(e)}remove(e){const t=this.resources.get(e);return!!t&&(this.refs.delete(t.id),this.resources.delete(e))}clear(){for(const e of this.refs.keys()){const t=this.refs.get(e);this.resources.delete(t)}this.refs.clear()}}const M=(e=>()=>(e||(e=new A),e))();class $ extends a{constructor(){super(),this.pools={},this.register(M())}createPool(){const e=new A;return this.register(e),e}register(e){return!m(this.pools,e.id)&&(this.pools[e.id]=e,!0)}get(e){return this.pools[e]||null}isRegistered(e){return m(this.pools,e.id)}remove(e){const t="string"==typeof e?e:e.id;return delete this.pools[t]}}const N=(e=>()=>(e||(e=new $),e))(),H=N().createPool(),D=e=>{if(!j(e))return e;const{poolId:t,id:r}=e,o=N().get(t);if(!o)throw new Error(`Resource Pool "${t}" does not exist.`);const s=o.getById(r);if(!s)throw new Error(`Resource "${r}" does not exist, pool "${t}".`);return s};var Y,G;!function(e){e.HOST="host",e.GUEST="guest"}(Y||(Y={})),function(e){e.REQUEST="request",e.RESPONSE="response"}(G||(G={}));const U=n("wi"),_=n("m"),J=async e=>{if(!e)return e;if(e instanceof Array){const t=[];for(let r of e)t.push(await J(r));return t}if((t=e)&&t[l]){const t=await(e=>e&&e[l]&&e[l].getTarget()||e)(e);return J(t)}var t;if("function"==typeof e){return H.set(e).toObject()}return e},W=(e="")=>t=>t&&"object"==typeof t&&"string"==typeof t.id&&(!e&&t.id.match(/^wi/)||e&&e===t.id),z=({handler:e,timeout:t,timeoutError:r=`Async operation didn't complete in ${t}ms.`,onTimeout:o})=>{const s="function"==typeof e?new Promise(e):e;return t?Promise.race([s,new Promise(((e,s)=>setTimeout((()=>{s(r),o&&o(r)}),t)))]):s},B=e=>e instanceof Event?e.data:e,q=({type:e,remoteId:t,handshakeTimeout:r,...o})=>{const s={...o,isMessage:W(t)},n=e===Y.HOST?(({id:e,root:t,isMessage:r,subscribe:o,unsubscribe:s,sendMessage:n,preprocessResponse:i=(e=>e)})=>a=>{const c=o=>{const u=B(i(o));r(u)&&(s(c),n({id:e,root:t}),a(u))};o(c)})(s):(({id:e,root:t,isMessage:r,subscribe:o,unsubscribe:s,sendMessage:n,handshakeInterval:i,preprocessResponse:a=(e=>e)})=>c=>{let u;const d=e=>{const t=B(a(e));r(t)&&(s(d),clearInterval(u),c(t))};o(d);const p=()=>n({id:e,root:t});i?u=setInterval(p,i):p()})(s);return z({handler:n,timeout:r,timeoutError:`Handshake sequence could not complete in ${r}ms.`})},Q="message",F=e=>{if(e.addEventListener)return{subscribe:t=>e.addEventListener(Q,t),unsubscribe:t=>e.removeEventListener(Q,t)};if(e.addListener)return{subscribe:t=>e.addListener(Q,t),unsubscribe:t=>e.removeListener(Q,t)};if(e.on)return{subscribe:t=>e.on(Q,t),unsubscribe:t=>e.off(Q,t)};throw new Error('Worker instance does not implement EventEmitter insterface, it must expose "addEventListener"/"removeEventListener", "addListener"/"removeListener" or "on"/"off" method pair.')},K=Promise.resolve(void 0),V=(e,t,r)=>{switch(t){case o.THEN:return e.then(...r);case o.CATCH:return e.catch(...r);default:throw new Error(`Unexpected Error: Promise method "${String(t)}" could not be called.`)}},X=(e,t=!0)=>(r,o)=>{const n=(r,o)=>{const i=(a=(r,i,a,c)=>{const p=((e,t,r,o,s,n)=>t===d.APPLY&&n&&e?.type===d.GET?new u(e.prev,d.METHOD_CALL,e.name,o,e.context):new u(e,t,r,o,s))(o,r,i,a,c,t);let l;return(e=>{const{type:t}=e;return t===d.GET||t===d.METHOD_CALL?s(e.name):t===d.APPLY&&s(e.prev?.name)})(p)?((e,t,r,o)=>{switch(e.type){case d.GET:{const{name:s,prev:n}=e;let{context:i}=e;if(r){if(!n)throw new Error("Unexpected Error: Proxy command GET has unknown context.");i=t(n,n.context,o)}return(...e)=>i[s](...e)}case d.METHOD_CALL:if(!e.context)throw new Error("Unexpected Error: Could not apply Promise method of unknown context.");return V(e.context,e.name,e.value);case d.APPLY:{const{prev:t}=e;if(!t?.context||!t?.name)throw new Error("Unexpected Error: Could not apply Promise method of unknown context.");return V(t.context,t.name,e.value)}default:throw new Error(`Command type "${e.type}" could not be executed as a Promise command.`)}})(p,e,t,n):(l=r!==d.APPLY&&r!==d.GET||!t?e(p,c,n):K,n(l,p))},{get:y(a),apply:w(a),set:E(a),deleteProperty:g(a),has:b,ownKeys:P,enumerate:T,getOwnPropertyDescriptor:S});var a;return h(r,i,{getCommand:()=>o,dropCommandChain(){o&&delete o.prev}})};return n(Promise.resolve(r),o?u.fromCommand(o):void 0)},Z=async({id:e,root:t,...r})=>{const o=e||U(),s=t?H.set(t).toObject():void 0,{subscribe:n,unsubscribe:i,sendMessage:a,preprocessResponse:c=(e=>e)}=r,{id:u,root:p}=await q({id:o,root:s,...r}),l=new Map,h=(m=o,e=>e&&"object"==typeof e&&"string"==typeof e.id&&m===e.target);var m;const f=((e,t)=>async(r,o,s=_())=>{const n=r.toObject(),i=await o;if(n.type===d.APPLY){let e;r.prev&&(e=await r.prev.context),n.value=[e,await J(n.value)]}else n.value=await J(n.value);return{id:s,type:G.REQUEST,source:e,target:t,command:n,context:i}})(o,u),v=(y=o,({id:e,source:t},r,o)=>({id:e,type:G.RESPONSE,source:y,target:t,value:r,error:o}));var y;const w=async e=>{const t=B(c(e));if(h(t))switch(t.type){case G.REQUEST:{const e=t;try{const t=await(({command:e,command:{type:t,value:r},context:o})=>{const s=D(o),n=e.name;if(t!==d.APPLY&&!s)throw new Error(`Cannot excute command ${t}/${String(n)} on non existent target(${s}).`);let i;switch(t){case d.GET:i=s[n];break;case d.SET:return s[n]=D(r);case d.DELETE_PROPERTY:return delete s[n];case d.APPLY:{const[e,t]=r;i=s.apply(D(e),t.map(D))}break;case d.METHOD_CALL:i=s[n](...r.map(D))}if(i&&"function"==typeof i)return H.set(i).toObject();return i})(e);a(v(e,t))}catch(t){a(v(e,void 0,{message:t.message}))}}break;case G.RESPONSE:{const{id:e,value:r,error:o}=t,{resolve:s,reject:n}=l.get(e)||{};n&&o?n(o):s&&s(r)}}};n(w);const E=()=>i(w);if(!p)return{stop:E,pool:H};const g=X((async(e,t,o)=>{const{responseTimeout:s}=r,n=_(),i=`Could not receive command ${e.type}/${String(e.name)} response in ${s}ms.`,c=z({handler:async(r,o)=>{const s=await f(e,t,n);a(s),l.set(n,{resolve:r,reject:o})},timeout:s||0,timeoutError:i,onTimeout:()=>{const e=l.get(n);e&&(e.reject(new Error(i)),l.delete(n))}}),u=await c;return j(u)?o(c,e):c}),!1);return{stop:E,pool:H,wrap:g,pendingRequests:l,root:p?g(p):null}},ee=e=>async({ws:t,eventEmitter:r=t,messageSender:o=t,...s})=>Z({sendMessage:e=>o.send(JSON.stringify(e)),preprocessResponse:e=>JSON.parse(B(e)),...F(r),...s,type:e,handshakeInterval:0}),te=ee(Y.GUEST),re=ee(Y.HOST);e.forWebSocketToConnect=async e=>{const{readyState:t}=e;switch(t){case 0:return new Promise(((t,r)=>{const o=()=>{e.removeEventListener("open",s),e.removeEventListener("close",n),e.removeEventListener("error",n)},s=()=>{t(e),o()},n=e=>{r(e),o()};e.addEventListener("open",s),e.addEventListener("close",n),e.addEventListener("error",n)}));case 1:return e;case 2:throw new Error("WebSocket: The connection is in the process of closing.");case 3:throw new Error("WebSocket: The connection is closed or couldn't be opened.");default:throw new Error(`WebSocket: Unknown readyState value "${t}".`)}},e.initializeClient=re,e.initializeServer=te,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=websocket-interface.umd.js.map
